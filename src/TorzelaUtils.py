#!/usr/bin/env python3

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from string import ascii_letters
from random import choice

def createRandomMessage(messageSize):
   chars = ascii_letters + ".,:;-+*/?!()[]{}"
   return ''.join(choice(chars) for i in range(messageSize))

def createKeyGenerator():
   return dh.generate_parameters(generator=2, key_size=512, 
                                 backend=default_backend())

def createCipher(sharedSecret):
   # the msg must be multiple of 16
   # iv is a 16 block of random bytes generated by os.urandom(16)
   iv = b'+\xed6\xdd\xf0\xb1\x17\xa2\xa7\x12\x13\xd3\xd0\xf9\x14\xac'
   return Cipher(algorithms.AES(sharedSecret), modes.CBC(iv), 
                 backend=default_backend())

# Generate a pair of public and private keys
def generateKeys(keyGenerator):
   privateKey = keyGenerator.generate_private_key()
   publicKey = privateKey.public_key()
   return privateKey, publicKey

def computeSharedSecret(myPrivateKey, otherPublicKey):
   shared_key = myPrivateKey.exchange(otherPublicKey)

   sharedSecret = HKDF(
         algorithm=hashes.SHA256(),
         length=32,
         salt=None,
         info=b'handshake data',
         backend=default_backend()
      ).derive(shared_key)   
   
   return sharedSecret

# Encrypt the message using symmetric encryption.
# sharedSecret is the shared secret and msg is a string containing the 
# message to encrypt. Returns a stream of bytes
# Warning: the cipher used must be the same for encryption than for decryption. 
def encryptMessage(shared_secret, msg):
   # TODO: fix msg size to 256. Give an error if len(msg) > msg_size
   #   padder = padding.PKCS7(algorithms.AES.block_size).padder()
   #     padded_data = padder.update(data) + padder.finalize()
   
   cipher = createCipher(shared_secret)
   encryptor = cipher.encryptor()
   e = encryptor.update(msg.encode()) + encryptor.finalize()
   return e

# Decrypt the message using symmetric encryption.
# sharedSecret is the shared secret and msg is an array of bytes containing
# the encrypted message. Returns a string
def decryptMessage(shared_secret, msg):
   # TODO: fix msg size to 256. Give an error if len(msg) > msg_size
   # unpadder = PKCS7(128).unpadder()
   #	 decrypted = unpadder.update(plain)
   
   cipher = createCipher(shared_secret)
   decryptor = cipher.decryptor()
   dt = decryptor.update(msg) + decryptor.finalize()
   return dt.decode()


def testEncryption():
   keyGenerator = createKeyGenerator()
   
   a_private_key, a_public_key = generateKeys(keyGenerator)
   b_private_key, b_public_key = generateKeys(keyGenerator)
   
   msg = "16 chars msg...."
   
   # Alice encrypts the message using her private key and Bob's public key
   a_shared_secret = computeSharedSecret(a_private_key, b_public_key)
   e = encryptMessage(a_shared_secret, msg)
   
   # Bob decrypts the message using his private key and Alice's public key
   b_shared_secret = computeSharedSecret(b_private_key, a_public_key)
   answer = decryptMessage(b_shared_secret, e)
   
   if a_shared_secret != b_shared_secret:
      print("FAILURE: shared secret different")
   elif answer != msg:
      print("FAILURE: on encryption")
   else:
      print("SUCESS")
   
   
   
   
   
   






